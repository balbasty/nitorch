import torch
from nitorch.core import py, utils, fft
from nitorch import spatial
from nitorch.tools.img_statistics import estimate_noise
from typing import Optional
from torch import Tensor
import math as pymath


def _laplacian_freq(shape, **backend):
    """
    Compute Fourier squared frequency on the lattice and its inverse.
    """
    dim = len(shape)
    shape = torch.as_tensor(shape, **backend)
    g = spatial.identity_grid(shape, **backend)
    g -= shape // 2
    g /= shape
    g = g.square_().sum(-1)
    g = fft.ifftshift(g, dim=list(range(dim)))
    ig = g.reciprocal()
    ig[(0,) * dim] = 0
    return g, ig


def _laplacian_filter(phase, freq, dims):
    """
    Assumes ifftshift has been applied to phase and freq.
    Eq (5) from Schofield and Zhu.
    """
    g, ig = freq

    s = phase.sin()
    c = phase.cos()

    fft_ = lambda x: fft.fftn(x, dim=dims)
    ifft_ = lambda x: fft.ifftn(x, dim=dims)

    phase = ifft_(fft_(s).mul_(g)).mul_(c)
    phase -= ifft_(fft_(c).mul_(g)).mul_(s)
    phase = ifft_(fft_(phase).mul_(ig))
    phase = fft.real(phase)

    return phase


def unwrap(phase, dim=None, bound='dct2', max_iter=0, tol=1e-5):
    """Laplacian unwrapping of the phase

    Parameters
    ----------
    phase : tensor
        Wrapped phase, in radian
    dim : int, default=phase.dim()
        Number of spatial dimensions
    max_iter : int, default=0
        Maximum number of unwrapping iterations.
        If 0, return the Laplacian filtered phase, which is not exactly
        equal to the input phase modulo 2 pi.
    tol : float, default=1e-5
        Tolerance for early stopping


    Returns
    -------
    unwrapped : tensor

    References
    ----------
    .. "Fast phase unwrapping algorithm for interferometric applications"
       Marvin A. Schofield and Yimei Zhu
       Optics Letters (2003)

    """
    # TODO: would be nice to use DCT/DST rather than padding once they
    #       are available in PyTorch.

    dim = dim or phase.dim()
    dims = list(range(-dim, 0))
    shape = bigshape = phase.shape[-dim:]

    if bound not in ('dct', 'circulant'):
        phase = utils.pad(phase, [d//2 for d in shape], side='both', mode=bound)
        bigshape = phase.shape[-dim:]

    freq = _laplacian_freq(bigshape, **utils.backend(phase))
    phase = fft.ifftshift(phase, dim=dims)
    twopi = 2 * pymath.pi

    if max_iter == 0:
        phase = _laplacian_filter(phase, freq, dims)
    else:
        for n_iter in range(1, max_iter+1):
            filtered_phase = _laplacian_filter(phase, freq, dims)
            filtered_phase.sub_(phase).div_(twopi).round_().mul_(twopi)
            phase += filtered_phase

            if n_iter < max_iter and filtered_phase.mean() < tol:
                break

    phase = fft.fftshift(phase, dim=dims)

    if bound not in ('dct', 'circulant'):
        slicer = [slice(d//2, d+d//2) for d in shape]
        phase = phase[(Ellipsis, *slicer)]
    return phase


def mean_phase(phase, weight=None):
    """Compute the average phase using the circular mean

    Parameters
    ----------
    phase : tensor
    weight : tensor, optional

    Returns
    -------
    mean_phase : scalar tensor

    References
    ----------
    https://en.wikipedia.org/wiki/Circular_mean
    """
    if weight is not None:
        sumw = weight.sum()
        mean_cos = phase.cos().mul_(weight).sum() / sumw
        mean_sin = phase.sin().mul_(weight).sum() / sumw
    else:
        mean_cos = phase.cos().mean()
        mean_sin = phase.sin().mean()
    return torch.atan2(mean_sin, mean_cos)


@torch.jit.script
def derivatives(magnitude, phase, fit_log_magnitude, fit_phase,
                g:Optional[Tensor] = None, h: Optional[Tensor] = None):
    """
    Derivatives of the complex MSE wrt log parameters

    Parameters
    ----------
    magnitude : (*spatial) tensor
        Observed magnitude image
    phase : (*spatial) tensor
        Observed phase image
    fit_log_magnitude : (*spatial) tensor
        Current log magnitude fit
    fit_phase : (*spatial) tensor
        Current phase fit
    g, h : tensors, optional
        Output placeholders

    Returns
    -------
    nll : scalar tensor
        Negative log-likelihood
    g : (2, *spatial) tensor
        Gradient wrt to log_magnitude and phase
    h : (2, *spatial) tensor
        Approximate (diagonal) Hessian wrt to log_magnitude and phase

    """

    if g is None:
        g = magnitude.new_empty([2] + magnitude.shape)
    if h is None:
        h = magnitude.new_empty([2] + magnitude.shape)

    fit_magnitude = fit_log_magnitude.exp()

    prod_phase = phase.cos() * fit_phase.cos() + phase.sin() * fit_phase.sin()
    prod_phase = prod_phase * magnitude
    prod_phase_grad = phase.cos() * fit_phase.sin() - phase.sin() * fit_phase.cos()
    prod_phase_grad = prod_phase_grad * magnitude

    g[0] = fit_magnitude * (fit_magnitude - prod_phase)
    g[1] = fit_magnitude * prod_phase_grad
    h[0] = fit_magnitude * fit_magnitude + g[0].abs()
    h[1] = fit_magnitude * fit_magnitude

    ll = 0.5 * (magnitude * magnitude + fit_magnitude * fit_magnitude) - fit_magnitude * prod_phase
    ll = ll.sum()

    return ll, g, h


@torch.jit.script
def nll(magnitude, phase, fit_log_magnitude, fit_phase):
    """Negative log-likelihood of the Complex MSE, in each voxel

    Parameters
    ----------
    magnitude : (*spatial) tensor
        Observed magnitude image
    phase : (*spatial) tensor
        Observed phase image
    fit_log_magnitude : (*spatial) tensor
        Current log magnitude fit
    fit_phase : (*spatial) tensor
        Current phase fit

    Returns
    -------
    nll : (*spatial) tensor
    """
    fit_magnitude = fit_log_magnitude.exp()
    prod_phase = phase.cos() * fit_phase.cos() + phase.sin() * fit_phase.sin()
    prod_phase = prod_phase * magnitude

    ll = 0.5 * (magnitude * magnitude + fit_magnitude * fit_magnitude) - fit_magnitude * prod_phase
    return ll


def dot(x, y):
    """Dot product"""
    return x.flatten().dot(y.flatten())


def plot_fit(magnitude, phase, fit):
    import matplotlib.pyplot as plt
    plt.subplot(2, 3, 1)
    plt.imshow(magnitude[:, :, magnitude.shape[-1] // 2])
    plt.colorbar()
    plt.subplot(2, 3, 2)
    plt.imshow(fit[0, :, :, magnitude.shape[-1] // 2].exp())
    plt.colorbar()
    plt.subplot(2, 3, 4)
    plt.imshow(phase[:, :, magnitude.shape[-1] // 2], vmin=-0.5, vmax=0.5)
    plt.colorbar()
    plt.subplot(2, 3, 5)
    plt.imshow(fit[1, :, :, magnitude.shape[-1] // 2], vmin=-0.5, vmax=0.5)
    plt.colorbar()
    plt.subplot(2, 3, 6)
    diff = nll(
        magnitude[:, :, magnitude.shape[-1] // 2],
        phase[:, :, magnitude.shape[-1] // 2],
        fit[0, :, :, magnitude.shape[-1] // 2],
        fit[1, :, :, magnitude.shape[-1] // 2])
    plt.imshow(diff)
    plt.colorbar()
    plt.show()


def phase_fit(magnitude, phase, lam=(0, 1e1), penalty=('membrane', 'bending'),
              max_iter=20, tol=1e-5):
    """Fit a complex image using a decreasing phase regularization

    Parameters
    ----------
    magnitude : tensor
    phase : tensor
    lam : (float, float)
    penalty : (str, str)

    Returns
    -------
    magnitude : tensor
    phase : tensor

    """

    # estimate noise precision
    sd = estimate_noise(magnitude)[0]['sd']
    prec = 1 / (sd * sd)

    # initialize fit
    fit = magnitude.new_empty([2, *magnitude.shape])
    fit[0] = magnitude
    fit[0].clamp_min_(1e-8).log_()
    fit[1] = mean_phase(phase, magnitude)

    # allocate placeholders
    g = magnitude.new_empty([2, *magnitude.shape])
    h = magnitude.new_empty([2, *magnitude.shape])
    n = magnitude.numel()

    # prepare regularizer options
    prm = dict(
        membrane=[lam[0] * int(penalty[0] == 'membrane'),
                  lam[1] * int(penalty[1] == 'membrane')],
        bending=[lam[0] * int(penalty[0] == 'bending'),
                 lam[1] * int(penalty[1] == 'bending')],
        bound='dct2')

    lam0 = dict(membrane=prm['membrane'][-1], bending=prm['bending'][-1])
    ll0 = lr0 = factor = float('inf')
    for n_iter in range(max_iter):

        # decrease regularization
        factor, factor_prev = 1 + 10 ** (5 - n_iter), factor
        factor_ratio = factor / factor_prev if n_iter else float('inf')
        prm['membrane'][-1] = lam0['membrane'] * factor
        prm['bending'][-1] = lam0['bending'] * factor

        # compute derivatives
        ll, g, h = derivatives(magnitude, phase, fit[0], fit[1], g, h)
        ll *= prec
        g *= prec
        h *= prec

        # compute regularization
        reg = spatial.regulariser(fit, **prm)
        lr = 0.5 * dot(fit, reg)
        g += reg

        # Gauss-Newton step
        fit -= spatial.solve_field_fmg(h, g, **prm)

        # Compute progress
        l0 = ll0 + factor_ratio * lr0
        l = ll + lr
        gain = l0 - l
        print(f'{n_iter:02d} | {ll/n:12.6g} + {lr/n:12.6g} = {l/n:12.6g} '
              f'| gain = {gain/n:12.6g}')
        if abs(gain) < n * tol:
            break

        ll0, lr0 = ll, lr
        # plot_fit(magnitude, phase, fit)

    return fit[0].exp_(), fit[1]


def phase_fit_vm(magnitude, phase, lam=1e1, sigma=None, penalty='bending',
                 max_iter=20, max_ls=12, tol=1e-5):
    """
    Smooth phase fit using a Von Mises likelihood with k = SNR**2

    Note that this is equivalent to fitting a complex Gaussian noise model,
    where the maximum-likelihood solution for the magnitude is obtained
    analytically and plugged back in the joint likelihood.
    """
    noise, tissue = estimate_noise(magnitude)
    if sigma is None:
        sigma = noise['sd']

    if penalty[0].lower() == 'm':
        # membrane
        reg = lambda x: spatial.regulariser(x, membrane=lam)
        solve = lambda h, g: spatial.solve_field_fmg(h, g, membrane=lam)
    else:
        # bending
        reg = lambda x: spatial.regulariser(x, bending=lam)
        solve = lambda h, g: spatial.solve_field_fmg(h, g, bending=lam)

    f = torch.zeros_like(phase)
    k = (magnitude/sigma).square()

    ll, lr = dot(k, (f - phase).cos_().neg_().add_(1)), 0
    print(f'{0:02d} '
          f'| {ll.item()/phase.numel():12.6g} + {0:12.6g} '
          f'= {(ll + lr).item()/phase.numel():12.6g}')

    factor = 1
    for n_iter in range(max_iter):

        factor, factor_prev = 1 + 10 ** (5 - n_iter), factor
        factor_ratio = factor / factor_prev if n_iter else 1
        lr *= factor_ratio

        g = (f - phase).sin_().mul_(k)
        g += reg(f)

        d = solve(k, g)

        dd = reg(d)
        df = dot(dd, f)
        dd = dot(dd, dd)
        armijo, armijo_prev, success = 1, 0, False
        for n_ls in range(max_ls):
            f.sub_(d, alpha=armijo - armijo_prev)
            new_ll = dot(k, (f - phase).cos_().neg_().add_(1))
            new_lr = 0.5 * armijo * (armijo * dd - 2 * df)
            if new_ll + new_lr < ll:
                success = True
                break
            armijo /= 2

        if not success:
            f.add_(d, alpha=armijo_prev)
            break

        old_ll, old_lr = ll, lr
        ll, lr = new_ll, lr + new_lr
        l, old_l = ll + lr, old_ll + old_lr
        gain = old_l - l
        print(f'{n_iter+1:02d} '
              f'| {ll.item()/phase.numel():12.6g} '
              f'+ {lr.item()/phase.numel():12.6g} '
              f'= {(ll + lr).item()/phase.numel():12.6g} '
              f'| gain = {gain/phase.numel():12.6g}')
        if gain < tol * phase.numel():
            break

    return f


def phase_fit_gauss(magnitude, phase, lam=1e1, sigma=None, penalty='bending',
                    max_iter=20, max_ls=12, tol=1e-5):
    """
    Smooth phase fit using a Gaussian likelihood with k = SNR**2

    Input phase should be unwrapped!
    """
    noise, tissue = estimate_noise(magnitude)
    if sigma is None:
        sigma = noise['sd']

    if penalty[0].lower() == 'm':
        # membrane
        reg = lambda x: spatial.regulariser(x, membrane=lam)
        solve = lambda h, g: spatial.solve_field_fmg(h, g, membrane=lam)
    else:
        # bending
        reg = lambda x: spatial.regulariser(x, bending=lam)
        solve = lambda h, g: spatial.solve_field_fmg(h, g, bending=lam)

    f = torch.zeros_like(phase)
    k = magnitude.square().div_(sigma**2)

    ll, lr = 0.5 * dot(k, (f - phase).square_()), 0
    print(f'{0:02d} '
          f'| {ll.item()/phase.numel():12.6g} + {0:12.6g} '
          f'= {(ll + lr).item()/phase.numel():12.6g}')

    factor = 1
    for n_iter in range(max_iter):

        factor, factor_prev = 1 + 10 ** (5 - n_iter), factor
        factor_ratio = factor / factor_prev if n_iter else 1
        lr *= factor_ratio

        g = (f - phase).mul_(k)
        g += reg(f)

        d = solve(k, g)

        dd = reg(d)
        df = dot(dd, f)
        dd = dot(dd, dd)
        armijo, armijo_prev, success = 1, 0, False
        for n_ls in range(max_ls):
            f.sub_(d, alpha=armijo - armijo_prev)
            new_ll = 0.5 * dot(k, (f - phase).square_())
            new_lr = 0.5 * armijo * (armijo * dd - 2 * df)
            if new_ll + new_lr < ll:
                success = True
                break
            armijo /= 2

        if not success:
            f.add_(d, alpha=armijo_prev)
            break

        old_ll, old_lr = ll, lr
        ll, lr = new_ll, lr + new_lr
        l, old_l = ll + lr, old_ll + old_lr
        gain = old_l - l
        print(f'{n_iter+1:02d} '
              f'| {ll.item()/phase.numel():12.6g} '
              f'+ {lr.item()/phase.numel():12.6g} '
              f'= {(ll + lr).item()/phase.numel():12.6g} '
              f'| gain = {gain/phase.numel():12.6g}')
        if gain < tol * phase.numel():
            break

    return f


def b0_rad_to_hz(phase, delta_te, delta_frequency=0):
    """Convert a phase-difference image to a fieldmap in Hz

    Parameters
    ----------
    phase : tensor
        Phase difference image
    delta_te : float
        Echo time difference of the original images, in sec
    delta_frequency : float
        Difference of center frequencies between the target acquisition
        and fieldmap acquisition, in Hz

    Returns
    -------
    fmap : tensor
        Fieldmap in Hz

    """
    fmap = phase / (delta_te * 2 * pymath.pi)
    if delta_frequency:
        fmap += delta_frequency
    return fmap


def b0_hz_to_vox(fmap, bandwidth):
    """Convert fieldmap in Hz to displacement map in voxel

    Parameters
    ----------
    fmap : tensor
        Fieldmap, in Hz
    bandwidth : float, Hz/pixel

    Returns
    -------
    disp : tensor
        displacement map

    """
    return fmap / bandwidth