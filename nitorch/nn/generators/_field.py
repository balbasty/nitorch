import torch
import torch.distributions as td
from ..modules._base import Module
from ...core.utils import expand, unsqueeze, ensure_shape, max_backend
from ...core.constants import pi
from ...core.kernels import smooth
import math


class RandomFieldSample(Module):
    """Sample a smooth random field.

    The field is generated by sampling white Gaussian noise and
    convolving it with a Gaussian kernel.

    """

    def __init__(self, shape=None, mean=0, amplitude=1, fwhm=1, channel=1,
                 basis=1, device='cpu', dtype=None):
        """

        Parameters
        ----------
        shape : sequence[int], optional
            Lattice shape
        mean : callable or tensor, default=0
            Mean value. Should broadcast to (channel, *shape)
        amplitude : callable or tensor, default=1
            Amplitude of the squared-exponential kernel.
            Should broadcast to (channel, *shape)
        fwhm : callable or tensor, default=1
            Full-width at Half Maximum of the squared-exponential kernel.
            Should broadcast to (channel, ndim)
        channel : int, default=1
            Number of channels
        basis : {0, 1}, default=1
            See `nitorch.core.kernels.smooth`
        device : torch.device: default='cpu'
            Output tensor device.
        dtype : torch.dtype, default=torch.get_default_dtype()
            Output tensor datatype.

        """
        super().__init__()
        self.shape = shape
        self.mean = mean
        self.amplitude = amplitude
        self.fwhm = fwhm
        self.channel = channel
        self.basis = basis
        self.device = device
        if dtype is None or not dtype.is_floating_point:
            dtype = torch.get_default_dtype()
        self.dtype = dtype

    def forward(self, batch=1, **overload):
        """

        Parameters
        ----------
        batch : int, default=1
            Batch size
        overload : dict

        Returns
        -------
        field : (batch, channel, *shape) tensor
            Generated random field

        """

        # get arguments
        shape = overload.get('shape', self.shape)
        mean = overload.get('mean', self.mean)
        amplitude = overload.get('amplitude', self.amplitude)
        fwhm = overload.get('fwhm', self.fwhm)
        channel = overload.get('channel', self.channel)
        basis = overload.get('basis', self.basis)
        dtype = overload.get('dtype', self.dtype)
        device = overload.get('device', self.device)

        # sample if parameters are callable
        mean = mean() if callable(mean) else mean
        amplitude = amplitude() if callable(amplitude) else amplitude
        fwhm = fwhm() if callable(fwhm) else fwhm

        # device/dtype
        mean = torch.as_tensor(mean, dtype=dtype, device=device)
        amplitude = torch.as_tensor(amplitude, dtype=dtype, device=device)
        fwhm = torch.as_tensor(fwhm, dtype=dtype, device=device)

        # reshape
        nb_dim = len(shape)
        full_shape = [batch, channel, *shape]
        mean = mean.expand(full_shape)
        amplitude = amplitude.expand(full_shape)
        fwhm = fwhm.expand([basis, channel, nb_dim])

        conv = torch.nn.functional.conv1d if nb_dim == 1 else \
               torch.nn.functional.conv2d if nb_dim == 2 else \
               torch.nn.functional.conv3d if nb_dim == 3 else None

        # convert SE parameters to noise/kernel parameters
        sigma_se = fwhm / math.sqrt(8*math.log(2))
        sigma_se = unsqueeze(sigma_se.prod(dim=-1), dim=-1, ndim=nb_dim)
        amplitude = amplitude * (2*pi)**(nb_dim/4) * sigma_se.sqrt()
        fwhm = fwhm * math.sqrt(2)

        # smooth
        samples_b = []
        for b in range(batch):
            samples_c = []
            for c in range(channel):
                kernel = smooth('gauss', fwhm[b, c], basis=basis,
                                device=device, dtype=dtype)

                # compute input shape
                pad_shape = [shape[d] + kernel[d].shape[d+2] - 1
                             for d in range(nb_dim)]
                mean1 = ensure_shape(mean[b, c], pad_shape,
                                     mode='reflect2', side='both')
                amplitude1 = ensure_shape(amplitude[b, c], pad_shape,
                                          mode='reflect2', side='both')

                # generate sample
                sample = torch.distributions.Normal(mean1, amplitude1).sample()
                sample = sample[None, None, ...]

                # convolve
                for ker in kernel:
                    sample = conv(sample, ker)

                samples_c.append(sample)

            samples_b.append(torch.cat(samples_c, dim=1))

        sample = torch.cat(samples_b, dim=0)

        return sample


class BiasFieldTransform(Module):
    """Apply a random multiplicative bias field to an image."""

    def __init__(self, mean=None, amplitude=None, fwhm=None):
        """

        Parameters
        ----------
        mean : callable or tensor, default=0
            Mean value. Should broadcast to (channel, *shape)
        amplitude : callable or tensor, default=LogNormal(log(1), log(10)/3)
            Amplitude of the squared-exponential kernel.
            Should broadcast to (channel, *shape)
        fwhm : callable or tensor, default=LogNormal(log(5), log(2)/3)
            Full-width at Half Maximum of the squared-exponential kernel.
            Should broadcast to (channel, ndim)
        """

        super().__init__()
        mean = mean if mean is not None else self.default_mean
        amplitude = amplitude if amplitude is not None else self.default_amplitude
        fwhm = fwhm if fwhm is not None else self.default_fwhm
        self.field = RandomFieldSample(mean=mean, amplitude=amplitude,
                                       fwhm=fwhm)

    # defer properties
    mean = property(lambda self: self.field.mean)
    amplitude = property(lambda self: self.field.amplitude)
    fwhm = property(lambda self: self.field.fwhm)

    # default generators
    default_mean = lambda *b: torch.zeros(b)

    @staticmethod
    def default_amplitude(*b):
        return td.Normal(0., math.log(10)/3).sample(*b).exp()

    @staticmethod
    def default_fwhm(*b):
        return td.Normal(math.log(5.), math.log(2)/3).sample(*b).exp()

    def forward(self, image, **overload):
        """

        Parameters
        ----------
        image : (batch, channel, *shape)
            Input tensor
        overload : dict

        Returns
        -------
        transformed_image : (batch, channel, *shape)
            Bias-multiplied tensor

        """

        image = torch.as_tensor(image)
        bias = self.field(batch=image.shape[0], channel=image.shape[1],
                          shape=image.shape[2:], **overload)
        image = image * bias.exp()
        return image
